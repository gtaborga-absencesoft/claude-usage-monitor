#!/usr/bin/env python3
"""
Claude Usage Monitor - Terminal monitoring tool for Claude usage limits
Matches the actual claude.ai/settings/usage interface
Supports both manual and automatic extraction

Dependencies:
  pip install playwright rich
  playwright install firefox
"""

import os
import sys
import json
import re
import time
from datetime import datetime
from pathlib import Path
from rich.live import Live
from rich.console import Console
from rich.text import Text

# ANSI color codes
BLUE = '\033[94m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
MAGENTA = '\033[95m'
BOLD = '\033[1m'
DIM = '\033[2m'
RESET = '\033[0m'

CONFIG_DIR = Path.home() / '.config' / 'claude-usage'
CONFIG_FILE = CONFIG_DIR / 'usage.json'
FIREFOX_PROFILE_DIR = CONFIG_DIR / 'firefox-profile'

def ensure_config_dir():
    """Ensure config directory exists"""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)

def load_config():
    """Load usage configuration"""
    if not CONFIG_FILE.exists():
        return None
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"{RED}Error loading config: {e}{RESET}")
        return None

def save_config(config):
    """Save usage configuration"""
    ensure_config_dir()
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print(f"{RED}Error saving config: {e}{RESET}")
        return False

def create_progress_bar(percentage, width=40):
    """Create a visual progress bar from percentage"""
    percentage = min(max(percentage, 0), 100)  # Clamp between 0-100

    filled = int(width * percentage / 100)
    bar = '█' * filled + '░' * (width - filled)

    # Color based on usage
    if percentage >= 90:
        color = RED
    elif percentage >= 75:
        color = YELLOW
    else:
        color = GREEN

    return f"{color}{bar}{RESET} {percentage:.0f}%"

def get_chrome_user_data_dir():
    """Get Chrome user data directory based on OS"""
    home = Path.home()
    if sys.platform == 'darwin':  # macOS
        return home / 'Library' / 'Application Support' / 'Google' / 'Chrome'
    elif sys.platform == 'win32':  # Windows
        return home / 'AppData' / 'Local' / 'Google' / 'Chrome' / 'User Data'
    else:  # Linux
        return home / '.config' / 'google-chrome'

def get_firefox_profile_dir():
    """Get dedicated Firefox profile directory for automation

    Uses a dedicated profile at ~/.config/claude-usage/firefox-profile
    This avoids conflicts with system Firefox profiles.
    """
    return FIREFOX_PROFILE_DIR

def ensure_firefox_profile():
    """Ensure the dedicated Firefox profile directory exists"""
    FIREFOX_PROFILE_DIR.mkdir(parents=True, exist_ok=True)

def setup_firefox():
    """Launch Firefox with dedicated profile for initial setup/login"""
    try:
        from playwright.sync_api import sync_playwright
        from playwright._impl._errors import TargetClosedError
    except ImportError:
        print(f"{RED}Error: Playwright is not installed.{RESET}")
        print(f"\nTo use Firefox automation, install Playwright:")
        print(f"  {BOLD}pip install playwright{RESET}")
        print(f"  {BOLD}playwright install firefox{RESET}\n")
        return False

    ensure_firefox_profile()
    firefox_profile = get_firefox_profile_dir()

    print(f"\n{BOLD}{CYAN}Firefox Setup - One-Time Login{RESET}\n")
    print(f"{DIM}This will launch Firefox with a dedicated profile for automation.{RESET}")
    print(f"{DIM}Profile location: {firefox_profile}{RESET}\n")
    print(f"{BOLD}Instructions:{RESET}")
    print(f"  1. Firefox will open in a moment")
    print(f"  2. Navigate to: {CYAN}https://claude.ai/settings/usage{RESET}")
    print(f"  3. Log in to your Claude account")
    print(f"  4. Verify you can see the usage page")
    print(f"  5. Close the browser window when done")
    print(f"\n{YELLOW}After logging in once, just run 'claude-usage' to start monitoring!{RESET}\n")

    try:
        input(f"Press {BOLD}Enter{RESET} to launch Firefox...")
    except KeyboardInterrupt:
        print(f"\n\n{YELLOW}Setup cancelled.{RESET}\n")
        return False

    try:
        with sync_playwright() as p:
            print(f"\n{BLUE}Launching Firefox with dedicated profile...{RESET}\n")
            browser_context = p.firefox.launch_persistent_context(
                str(firefox_profile),
                headless=False
            )

            # Open the usage page
            page = browser_context.pages[0] if browser_context.pages else browser_context.new_page()
            page.goto('https://claude.ai/settings/usage', timeout=60000)

            print(f"{GREEN}✓ Firefox opened!{RESET}")
            print(f"{DIM}Log in and explore. Close the browser when done.{RESET}\n")

            # Wait for user to close the browser
            try:
                page.wait_for_event('close', timeout=0)
            except (TargetClosedError, Exception):
                pass

            # Close browser context safely
            try:
                browser_context.close()
            except (TargetClosedError, Exception):
                pass

            print(f"\n{GREEN}✓ Setup complete!{RESET}")
            print(f"\nJust run: {BOLD}claude-usage{RESET}")
            print(f"Starts continuous monitoring with auto-refresh every 5 minutes.")
            print(f"Press Ctrl+C to stop anytime.\n")
            return True

    except KeyboardInterrupt:
        print(f"\n\n{YELLOW}Setup cancelled.{RESET}\n")
        return False
    except Exception as e:
        print(f"\n{RED}Error during setup: {e}{RESET}\n")
        return False

def extract_usage_auto(browser='firefox', headless=False, progress_callback=None):
    """Automatically extract usage from claude.ai using browser automation

    Args:
        browser: 'firefox' or 'chrome' (default: 'firefox')
        headless: Run browser in headless mode (default: False)
        progress_callback: Optional callback function for progress updates
    """
    browser = browser.lower()
    if browser not in ['firefox', 'chrome']:
        print(f"{RED}Error: Invalid browser '{browser}'. Use 'firefox' or 'chrome'.{RESET}\n")
        return False

    try:
        from playwright.sync_api import sync_playwright
        from playwright._impl._errors import TargetClosedError
    except ImportError:
        print(f"{RED}Error: Playwright is not installed.{RESET}")
        print(f"\nTo use automatic extraction, install Playwright:")
        print(f"  {BOLD}pip install playwright{RESET}")
        print(f"  {BOLD}playwright install firefox chromium{RESET}")
        print(f"\nOr use manual entry:")
        print(f"  {BOLD}claude-usage manual{RESET}\n")
        return False

    if not headless:
        print(f"\n{BOLD}{CYAN}Automatic Usage Extraction{RESET}\n")
        print(f"{DIM}Opening {browser.title()} to extract usage data...{RESET}\n")

    def report_progress(message):
        """Helper to report progress if callback is provided"""
        if progress_callback:
            progress_callback(message)
        elif not headless:
            print(message)

    try:
        with sync_playwright() as p:
            # Try to use browser profile, but fallback if browser is already running
            browser_context = None
            page = None

            if browser == 'firefox':
                ensure_firefox_profile()
                firefox_profile = get_firefox_profile_dir()

                if firefox_profile.exists():
                    try:
                        report_progress(f"→ Launching Firefox...")
                        browser_context = p.firefox.launch_persistent_context(
                            str(firefox_profile),
                            headless=headless
                        )
                        page = browser_context.pages[0] if browser_context.pages else browser_context.new_page()
                    except Exception as e:
                        if "already in use" in str(e) or "lock" in str(e).lower():
                            print(f"{YELLOW}Firefox is currently running. Please close Firefox and try again.{RESET}")
                            print(f"\nAlternatively, you can:")
                            print(f"  1. Close all Firefox windows")
                            print(f"  2. Run: {BOLD}claude-usage auto{RESET}")
                            print(f"\nOr use manual mode:")
                            print(f"  {BOLD}claude-usage manual{RESET}\n")
                            return False
                        else:
                            raise

                if not browser_context:
                    report_progress(f"→ Launching Firefox without profile...")
                    browser_instance = p.firefox.launch(headless=headless)
                    browser_context = browser_instance
                    page = browser_instance.new_page()

            else:  # chrome
                chrome_data = get_chrome_user_data_dir()

                if chrome_data.exists():
                    try:
                        report_progress(f"→ Launching Chrome...")
                        browser_context = p.chromium.launch_persistent_context(
                            str(chrome_data),
                            headless=headless,
                            channel='chrome'
                        )
                        page = browser_context.pages[0] if browser_context.pages else browser_context.new_page()
                    except Exception as e:
                        if "ProcessSingleton" in str(e) or "already in use" in str(e):
                            print(f"{YELLOW}Chrome is currently running. Please close Chrome and try again.{RESET}")
                            print(f"\nAlternatively, you can:")
                            print(f"  1. Close all Chrome windows")
                            print(f"  2. Run: {BOLD}claude-usage auto --browser chrome{RESET}")
                            print(f"\nOr use manual mode:")
                            print(f"  {BOLD}claude-usage manual{RESET}\n")
                            return False
                        else:
                            raise

                if not browser_context:
                    report_progress(f"→ Launching Chrome without profile...")
                    browser_instance = p.chromium.launch(headless=headless)
                    browser_context = browser_instance
                    page = browser_instance.new_page()

            # Navigate to usage page
            report_progress(f"→ Loading claude.ai/settings/usage...")
            try:
                # Try with networkidle first (more reliable but slower)
                page.goto('https://claude.ai/settings/usage', wait_until='networkidle', timeout=60000)
            except Exception as e:
                if 'Timeout' in str(e):
                    # Fallback: use domcontentloaded which is faster and more reliable
                    report_progress(f"→ Retrying with faster load strategy...")
                    page.goto('https://claude.ai/settings/usage', wait_until='domcontentloaded', timeout=60000)
                else:
                    raise

            # Wait a bit for dynamic content to render
            page.wait_for_timeout(5000)

            # Extract the page content
            report_progress(f"→ Extracting usage data...")
            content = page.content()

            # Parse usage data from HTML
            # Look for patterns like "33% used", "84% used", etc.
            percentages = re.findall(r'(\d+)%\s+used', content, re.IGNORECASE)

            # Look for reset times - two patterns:
            # Type A: "Resets in X hr Y min" (relative time - current session)
            # Type B: "Resets Day HH:MM AM/PM" (absolute time - weekly limits)

            # Find all "Resets" patterns with their positions to preserve order
            all_resets = []

            # Pattern A1: "Resets in" + hours and minutes
            for match in re.finditer(r'Resets in\s+(\d+\s+(?:hr|hour|hours?)\s+\d+\s+(?:min|mins|minute|minutes?))', content, re.IGNORECASE):
                all_resets.append((match.start(), 'in', match.group(1)))

            # Pattern A2: "Resets in" + minutes only
            for match in re.finditer(r'Resets in\s+(\d+\s+(?:min|mins|minute|minutes?))', content, re.IGNORECASE):
                all_resets.append((match.start(), 'in', match.group(1)))

            # Pattern A3: "Resets in" + hours only
            for match in re.finditer(r'Resets in\s+(\d+\s+(?:hr|hour|hours?))', content, re.IGNORECASE):
                all_resets.append((match.start(), 'in', match.group(1)))

            # Pattern B: "Resets" + day/time (e.g., "Resets Thu 9:00 AM")
            for match in re.finditer(r'Resets\s+((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)[a-z]*\s+\d{1,2}:\d{2}\s+[AP]M)', content, re.IGNORECASE):
                all_resets.append((match.start(), 'at', match.group(1)))

            # Sort by position in HTML to maintain correct order
            all_resets.sort(key=lambda x: x[0])

            # Extract just the type and time (remove position)
            reset_times = [(reset_type, time) for _, reset_type, time in all_resets]

            # Close browser context safely
            try:
                browser_context.close()
            except (TargetClosedError, Exception):
                # Context already closed, ignore
                pass

            if len(percentages) >= 2:  # Need at least current session and weekly
                # Extract values
                current_percent = int(percentages[0]) if len(percentages) > 0 else 0
                weekly_percent = int(percentages[1]) if len(percentages) > 1 else 0
                opus_percent = int(percentages[2]) if len(percentages) > 2 else 0

                # Extract reset times with their type ('in' or 'at')
                # Strategy: First reset is always Current Session
                # Find the first absolute time pattern ('at' type) for weekly limits
                # Weekly limits (All Models and Opus) share the same reset time
                current_reset_type, current_reset = reset_times[0] if len(reset_times) > 0 else ('in', '')

                # Find first 'at' type for weekly reset (both All Models and Opus use this)
                weekly_reset_type = 'at'
                weekly_reset = ''
                for reset_type, reset_time in reset_times[1:]:  # Skip first one (current session)
                    if reset_type == 'at':
                        weekly_reset_type = reset_type
                        weekly_reset = reset_time
                        break

                # If no 'at' type found, fall back to second reset time
                if not weekly_reset and len(reset_times) > 1:
                    weekly_reset_type, weekly_reset = reset_times[1]

                # Opus uses same reset as weekly
                opus_reset_type = weekly_reset_type
                opus_reset = weekly_reset

                current_reset = current_reset.strip()
                weekly_reset = weekly_reset.strip()
                opus_reset = opus_reset.strip()

                if not headless:
                    print(f"\n{GREEN}✓ Successfully extracted usage data:{RESET}")
                    reset_in_or_at = "in" if current_reset_type == "in" else ""
                    print(f"  Current Session: {current_percent}% (resets {reset_in_or_at} {current_reset})")
                    reset_in_or_at = "in" if weekly_reset_type == "in" else ""
                    print(f"  Weekly (All Models): {weekly_percent}% (resets {reset_in_or_at} {weekly_reset})")
                    reset_in_or_at = "in" if opus_reset_type == "in" else ""
                    print(f"  Weekly (Opus): {opus_percent}% (resets {reset_in_or_at} {opus_reset})")

                # Detect plan from page content
                # The plan is stored in the data-org-plan attribute in the HTML
                # Example: data-org-plan="enterprise" or data-org-plan="pro" or data-org-plan="free"
                plan = None

                # Primary pattern: Look for data-org-plan attribute
                data_plan_match = re.search(r'data-org-plan=["\'](\w+)["\']', content, re.IGNORECASE)
                if data_plan_match:
                    plan_value = data_plan_match.group(1).lower()
                    # Capitalize first letter for consistency
                    plan = plan_value.capitalize()

                # Fallback patterns if data-org-plan is not found
                if not plan:
                    plan_patterns = [
                        # Look for plan name in other data attributes or JSON
                        (r'["\'](?:plan|tier|subscription)["\']:\s*["\']enterprise["\']', 'Enterprise'),
                        (r'["\'](?:plan|tier|subscription)["\']:\s*["\']pro["\']', 'Pro'),
                        (r'["\'](?:plan|tier|subscription)["\']:\s*["\']free["\']', 'Free'),
                    ]

                    for pattern, plan_name in plan_patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            plan = plan_name
                            break

                # Fallback: preserve existing plan from config if detection fails
                if not plan:
                    existing_config = load_config()
                    if existing_config and 'plan' in existing_config:
                        plan = existing_config['plan']
                        if not headless:
                            print(f"  Plan: {plan} (preserved from config)")
                    else:
                        plan = "Pro"  # Default only if no config exists
                        if not headless:
                            print(f"  Plan: {plan} (default)")
                else:
                    if not headless:
                        print(f"  Plan: {plan} (detected)")

                # Build config
                report_progress(f"→ Saving configuration...")
                new_config = {
                    'plan': plan,
                    'last_updated': datetime.now().isoformat(),
                    'extraction_method': 'automatic',
                    'current_session': {
                        'used_percent': current_percent,
                        'reset_time': current_reset,
                        'reset_type': current_reset_type
                    },
                    'weekly_all_models': {
                        'used_percent': weekly_percent,
                        'reset_time': weekly_reset,
                        'reset_type': weekly_reset_type
                    },
                    'weekly_opus': {
                        'used_percent': opus_percent,
                        'reset_time': opus_reset,
                        'reset_type': opus_reset_type
                    }
                }

                if save_config(new_config):
                    report_progress(f"{GREEN}✓ Update complete!{RESET}")
                    if not headless:
                        print(f"\nRun {BOLD}claude-usage{RESET} to view your usage.\n")
                    return True
                else:
                    report_progress(f"{RED}✗ Failed to save configuration{RESET}")
                    return False
            else:
                print(f"\n{RED}✗ Could not extract usage data from page{RESET}")
                print(f"{YELLOW}The page structure may have changed or you may need to log in.{RESET}")
                print(f"\nFallback to manual entry:")
                print(f"  {BOLD}claude-usage manual{RESET}\n")
                return False

    except KeyboardInterrupt:
        # User interrupted with Ctrl+C
        # Clean up browser context if it exists
        if 'browser_context' in locals() and browser_context:
            try:
                browser_context.close()
            except (TargetClosedError, Exception):
                pass
        raise  # Re-raise to be handled by caller
    except TargetClosedError:
        # Browser was closed unexpectedly
        print(f"\n{YELLOW}Browser was closed during extraction.{RESET}")
        return False
    except Exception as e:
        # Clean up browser context if it exists
        if 'browser_context' in locals() and browser_context:
            try:
                browser_context.close()
            except (TargetClosedError, Exception):
                pass
        print(f"\n{RED}Error during extraction: {e}{RESET}")
        print(f"\nFallback to manual update:")
        print(f"  {BOLD}claude-usage manual{RESET}\n")
        return False

def generate_countdown_text(remaining, spinner_idx):
    """Generate countdown text with spinner

    Args:
        remaining: Seconds remaining
        spinner_idx: Current spinner index

    Returns:
        str: Formatted countdown text
    """
    spinners = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
    spinner = spinners[spinner_idx % len(spinners)]

    minutes = remaining // 60
    secs = remaining % 60

    if minutes > 0:
        time_str = f"{minutes}m {secs}s"
    else:
        time_str = f"{secs}s"

    return f"{DIM}Next update in: {time_str} {spinner}{RESET}"

def auto_refresh_mode(browser='firefox', interval=300):
    """Run auto-refresh mode with continuous updates

    Args:
        browser: Browser to use ('firefox' or 'chrome')
        interval: Refresh interval in seconds (default: 300 = 5 minutes)
    """
    print(f"\n{BOLD}{CYAN}Auto-Refresh Mode{RESET}")
    print(f"{DIM}Monitoring usage every {interval // 60} minutes. Press Ctrl+C to stop.{RESET}\n")

    console = Console()

    progress_messages = []

    def progress_callback(message):
        """Collect progress messages without displaying"""
        progress_messages.append(message)

    first_run = True

    try:
        with Live(console=console, refresh_per_second=10) as live:
            while True:
                # Generate display content
                display_content = display_usage()
                display_content += f"\n{CYAN}─────────────────────────────────────────────────────────────────{RESET}\n"
                display_content += f"{DIM}Auto-refresh: Enabled (every {interval // 60} minutes) | Press Ctrl+C to stop{RESET}\n"

                # On first run, display cached data immediately then update
                if first_run:
                    first_run = False
                    # Display cached data
                    live.update(Text.from_ansi(display_content + f"\n{DIM}Updating usage...{RESET}"))

                    # Clear progress messages
                    progress_messages.clear()

                    # Run immediate extraction
                    try:
                        success = extract_usage_auto(browser, headless=True, progress_callback=progress_callback)
                    except KeyboardInterrupt:
                        raise

                    if not success:
                        fail_msg = display_content + f"\n{YELLOW}Failed to update usage. Retrying in {interval // 60} minutes...{RESET}"
                        live.update(Text.from_ansi(fail_msg))

                    # Small pause before starting countdown
                    time.sleep(2)
                    continue

                # Countdown loop
                spinner_idx = 0
                try:
                    for remaining in range(interval, 0, -1):
                        countdown_text = generate_countdown_text(remaining, spinner_idx)
                        full_display = display_content + "\n" + countdown_text
                        # Use Text.from_ansi to convert ANSI codes to Rich format
                        rich_text = Text.from_ansi(full_display)
                        live.update(rich_text)
                        spinner_idx += 1
                        time.sleep(1)
                except KeyboardInterrupt:
                    raise

                # Show updating message
                update_msg = display_content + f"\n{DIM}Updating usage...{RESET}"
                live.update(Text.from_ansi(update_msg))

                # Clear progress messages for next run
                progress_messages.clear()

                # Run headless extraction
                try:
                    success = extract_usage_auto(browser, headless=True, progress_callback=progress_callback)
                except KeyboardInterrupt:
                    raise

                if not success:
                    fail_msg = display_content + f"\n{YELLOW}Failed to update usage. Retrying in {interval // 60} minutes...{RESET}"
                    live.update(Text.from_ansi(fail_msg))

                # Small pause before redisplaying
                time.sleep(2)

    except KeyboardInterrupt:
        print(f"\n\n{YELLOW}Auto-refresh stopped.{RESET}")
        print(f"Run {BOLD}claude-usage view{RESET} to view your current usage.\n")

def display_usage():
    """Generate usage information display string

    Returns:
        str: Formatted usage display
    """
    config = load_config()
    lines = []

    # Header
    lines.append(f"\n{BOLD}{CYAN}╔═══════════════════════════════════════════════════════════════╗{RESET}")
    lines.append(f"{BOLD}{CYAN}║                 Claude Usage Monitor                          ║{RESET}")
    lines.append(f"{BOLD}{CYAN}╚═══════════════════════════════════════════════════════════════╝{RESET}\n")

    if not config:
        lines.append(f"{YELLOW}No usage data configured yet.{RESET}")
        lines.append(f"\nRun {BOLD}claude-usage auto{RESET} for automatic extraction")
        lines.append(f"Or  {BOLD}claude-usage manual{RESET} for manual entry\n")
        lines.append(f"{DIM}Visit https://claude.ai/settings/usage to see your actual usage{RESET}\n")
        return '\n'.join(lines)

    # Display timestamp
    last_update = config.get('last_updated', 'Never')
    extraction_method = config.get('extraction_method', 'manual')
    if last_update != 'Never':
        last_update = datetime.fromisoformat(last_update).strftime('%Y-%m-%d %H:%M:%S')
    lines.append(f"{DIM}Last updated: {last_update} ({extraction_method}){RESET}\n")

    # Plan information
    plan = config.get('plan', 'Unknown')
    lines.append(f"{BOLD}Plan:{RESET} {MAGENTA}{plan}{RESET}\n")

    # Current session
    if 'current_session' in config:
        session = config['current_session']
        percent = session.get('used_percent', 0)
        reset_time = session.get('reset_time', 'Unknown')
        reset_type = session.get('reset_type', 'in')  # Default to 'in' for backwards compatibility

        lines.append(f"{BOLD}Current Session:{RESET}")
        lines.append(f"  {create_progress_bar(percent)}")
        if reset_time != 'Unknown' and reset_time:
            # Show "Resets in" for relative times, "Resets" for absolute times
            reset_prefix = "Resets in" if reset_type == 'in' else "Resets"
            lines.append(f"  {DIM}{reset_prefix} {reset_time}{RESET}\n")
        else:
            lines.append("")

    # Weekly limits - All models
    if 'weekly_all_models' in config:
        weekly = config['weekly_all_models']
        percent = weekly.get('used_percent', 0)
        reset_time = weekly.get('reset_time', 'Unknown')
        reset_type = weekly.get('reset_type', 'at')  # Default to 'at' for weekly limits

        lines.append(f"{BOLD}Weekly Limits (All Models):{RESET}")
        lines.append(f"  {create_progress_bar(percent)}")
        if reset_time != 'Unknown' and reset_time:
            # Show "Resets in" for relative times, "Resets" for absolute times
            reset_prefix = "Resets in" if reset_type == 'in' else "Resets"
            lines.append(f"  {DIM}{reset_prefix} {reset_time}{RESET}\n")
        else:
            lines.append("")

    # Weekly limits - Opus only
    if 'weekly_opus' in config:
        opus = config['weekly_opus']
        percent = opus.get('used_percent', 0)
        reset_time = opus.get('reset_time', 'Unknown')
        reset_type = opus.get('reset_type', 'at')  # Default to 'at' for weekly limits

        lines.append(f"{BOLD}Weekly Limits (Opus Only):{RESET}")
        lines.append(f"  {create_progress_bar(percent)}")
        if reset_time != 'Unknown' and reset_time:
            # Show "Resets in" for relative times, "Resets" for absolute times
            reset_prefix = "Resets in" if reset_type == 'in' else "Resets"
            lines.append(f"  {DIM}{reset_prefix} {reset_time}{RESET}\n")
        else:
            lines.append("")

    # Additional notes
    if 'notes' in config:
        lines.append(f"{BOLD}Notes:{RESET}")
        lines.append(f"  {config['notes']}\n")

    lines.append(f"{CYAN}─────────────────────────────────────────────────────────────────{RESET}")
    lines.append(f"\n{DIM}Monitor: claude-usage (continuous) | Once: claude-usage --once | Manual: claude-usage manual{RESET}")
    lines.append(f"{DIM}Help: claude-usage --help{RESET}\n")

    return '\n'.join(lines)

def manual_entry():
    """Interactive manual entry of usage information"""
    config = load_config() or {}

    print(f"\n{BOLD}{CYAN}Update Claude Usage Information{RESET}\n")
    print(f"{DIM}Visit https://claude.ai/settings/usage to see your current usage{RESET}\n")

    # Plan
    plan = input(f"Plan (Pro/Free/Enterprise) [{config.get('plan', 'Pro')}]: ").strip() or config.get('plan', 'Pro')

    # Current session
    print(f"\n{BOLD}Current Session:{RESET}")
    session_percent = input(f"Usage percentage [{config.get('current_session', {}).get('used_percent', 0)}]: ").strip()
    session_reset = input(f"Resets in (e.g., '2 hr 5 min') [{config.get('current_session', {}).get('reset_time', '')}]: ").strip()

    # Weekly limits - All models
    print(f"\n{BOLD}Weekly Limits (All Models):{RESET}")
    weekly_percent = input(f"Usage percentage [{config.get('weekly_all_models', {}).get('used_percent', 0)}]: ").strip()
    weekly_reset = input(f"Resets in (e.g., '16 hr 5 min') [{config.get('weekly_all_models', {}).get('reset_time', '')}]: ").strip()

    # Weekly limits - Opus only
    print(f"\n{BOLD}Weekly Limits (Opus Only):{RESET}")
    opus_percent = input(f"Usage percentage [{config.get('weekly_opus', {}).get('used_percent', 0)}]: ").strip()
    opus_reset = input(f"Resets in (e.g., '16 hr 5 min') [{config.get('weekly_opus', {}).get('reset_time', '')}]: ").strip()

    # Build config
    new_config = {
        'plan': plan,
        'last_updated': datetime.now().isoformat(),
        'extraction_method': 'manual',
        'current_session': {
            'used_percent': int(session_percent) if session_percent else config.get('current_session', {}).get('used_percent', 0),
            'reset_time': session_reset or config.get('current_session', {}).get('reset_time', '')
        },
        'weekly_all_models': {
            'used_percent': int(weekly_percent) if weekly_percent else config.get('weekly_all_models', {}).get('used_percent', 0),
            'reset_time': weekly_reset or config.get('weekly_all_models', {}).get('reset_time', '')
        },
        'weekly_opus': {
            'used_percent': int(opus_percent) if opus_percent else config.get('weekly_opus', {}).get('used_percent', 0),
            'reset_time': opus_reset or config.get('weekly_opus', {}).get('reset_time', '')
        }
    }

    if save_config(new_config):
        print(f"\n{GREEN}✓ Usage information updated successfully!{RESET}")
        print(f"\nRun {BOLD}claude-usage{RESET} to view your usage.\n")
    else:
        print(f"\n{RED}✗ Failed to save configuration{RESET}\n")

def show_help():
    """Display help information"""
    print(f"""
{BOLD}{CYAN}Claude Usage Monitor{RESET} - Terminal monitoring for Claude usage

{BOLD}USAGE:{RESET}
  claude-usage                      Auto-refresh mode (default, updates every 5 min)
  claude-usage --once               One-time extract + display, then exit
  claude-usage view                 Display cached data only (no extraction)
  claude-usage manual               Manual entry mode
  claude-usage setup-firefox        Set up Firefox profile (one-time login)
  claude-usage auto [browser]       Auto-extract with visible browser
  claude-usage --help               Show this help message

{BOLD}OPTIONS:{RESET}
  --once                            Extract once and display, then exit
  --browser NAME, -b NAME           Specify browser: firefox or chrome (for 'auto' mode)
  --headless                        Run in headless mode (for 'auto' mode)
  --interval SECONDS                Refresh interval in seconds (default: 300)

{BOLD}CONFIG FILE:{RESET}
  {CONFIG_FILE}

{BOLD}FIREFOX PROFILE:{RESET}
  {FIREFOX_PROFILE_DIR}

{BOLD}GETTING STARTED:{RESET}
  # 1. Install dependencies
  pip install playwright rich
  playwright install firefox

  # 2. Set up Firefox (one-time login)
  claude-usage setup-firefox
  # This opens Firefox - log in to Claude, then close the browser

  # 3. That's it! Just run:
  claude-usage
  # Starts continuous monitoring (updates every 5 minutes)
  # Press Ctrl+C to stop

{BOLD}EXAMPLES:{RESET}
  # Default: continuous auto-refresh (updates every 5 min)
  claude-usage

  # One-time extraction and display, then exit
  claude-usage --once

  # View cached data only (no extraction)
  claude-usage view

  # Manual entry mode
  claude-usage manual

  # First time setup with Firefox
  claude-usage setup-firefox

  # Visible browser extraction (for debugging)
  claude-usage auto

  # Auto-refresh with visible browser
  claude-usage auto --headless

{BOLD}AUTOMATIC EXTRACTION:{RESET}
  Browser options:
    firefox  - Uses dedicated profile (default, won't interfere with your browsers)
    chrome   - Uses your Chrome profile (requires closing Chrome first)

  Firefox setup:
    - Uses a dedicated profile at ~/.config/claude-usage/firefox-profile
    - Run 'claude-usage setup-firefox' once to log in
    - After that, just 'claude-usage' works seamlessly (headless by default)

{BOLD}NOTES:{RESET}
  - Default: Continuous monitoring (updates every 5 min, press Ctrl+C to stop)
  - Use 'claude-usage --once' for quick one-time check
  - Firefox uses a dedicated profile that won't conflict with your regular browsers
  - All extraction runs headless (no browser window) by default
  - Manual mode is always available as fallback
  - Data is stored locally and never shared

{BOLD}USAGE METRICS:{RESET}
  The tool tracks three metrics from claude.ai/settings/usage:

  1. Current Session - Usage in your current chat session
  2. Weekly Limits (All Models) - Combined usage across all Claude models
  3. Weekly Limits (Opus Only) - Usage specifically for Claude Opus
""")

if __name__ == "__main__":
    try:
        if len(sys.argv) > 1:
            cmd = sys.argv[1]
            if cmd in ['--help', '-h', 'help']:
                show_help()
            elif cmd == 'setup-firefox':
                setup_firefox()
            elif cmd == 'view':
                # Display only, no extraction
                print(display_usage())
            elif cmd == 'manual':
                # Manual entry
                manual_entry()
            elif cmd == '--once':
                # One-time extraction and display
                print(f"\n{BOLD}{CYAN}Fetching latest usage...{RESET}\n")
                success = extract_usage_auto('firefox', headless=True)
                print()  # Add spacing
                if success or CONFIG_FILE.exists():
                    print(display_usage())
                else:
                    print(f"{YELLOW}First time using claude-usage?{RESET}")
                    print(f"Run {BOLD}claude-usage setup-firefox{RESET} to set up automatic extraction")
                    print(f"Or use {BOLD}claude-usage manual{RESET} for manual entry\n")
            elif cmd == 'auto':
                # Parse parameters
                browser = 'firefox'  # Default to Firefox
                headless = False
                interval = 300  # Default 5 minutes

                i = 2
                while i < len(sys.argv):
                    arg = sys.argv[i]

                    if arg in ['--browser', '-b']:
                        if i + 1 < len(sys.argv):
                            browser = sys.argv[i + 1]
                            i += 2
                        else:
                            print(f"{RED}Error: --browser requires a value (firefox or chrome){RESET}\n")
                            sys.exit(1)
                    elif arg == '--headless':
                        headless = True
                        i += 1
                    elif arg == '--interval':
                        if i + 1 < len(sys.argv):
                            try:
                                interval = int(sys.argv[i + 1])
                                if interval < 1:
                                    print(f"{RED}Error: --interval must be positive{RESET}\n")
                                    sys.exit(1)
                            except ValueError:
                                print(f"{RED}Error: --interval requires a number (seconds){RESET}\n")
                                sys.exit(1)
                            i += 2
                        else:
                            print(f"{RED}Error: --interval requires a value (seconds){RESET}\n")
                            sys.exit(1)
                    elif arg in ['firefox', 'chrome']:
                        # Allow direct browser name without --browser flag
                        browser = arg
                        i += 1
                    else:
                        print(f"{RED}Error: Unknown parameter '{arg}'{RESET}\n")
                        sys.exit(1)

                # Run in appropriate mode
                if headless:
                    auto_refresh_mode(browser, interval)
                else:
                    extract_usage_auto(browser)
            else:
                print(f"{RED}Unknown command: {cmd}{RESET}")
                show_help()
        else:
            # DEFAULT: Continuous auto-refresh mode
            auto_refresh_mode('firefox', 300)
    except KeyboardInterrupt:
        print(f"\n\n{YELLOW}Interrupted.{RESET}")
        sys.exit(0)
